\documentclass{report}

\author{Patrick Lindsay}
\title{Software Engineering Notes}

\newcommand*{\glossaryname}{Dictionary}
\usepackage[nonumberlist]{glossaries}
\newcommand{\define}[2]{%
 \newglossaryentry{#1}{name=#1, description={#2}}%
 \glslink{#1}{}%
}
\makeglossaries

\begin{document}
\maketitle
\tableofcontents
\newpage
\part{Notes}
\chapter{Software Life-Cycle Model}
	\section{Overview}
	\underline{Software Engineering} - The application of sound engineering practices to software creation and maintenance.
		\subsection{Software development Life Cycle (Traditional Approach)}
			\begin{itemize}
				\item Requirements Phase
				\item Analysis or Specification Phase
				\item Design Phase
				\item Implementation/Integration Phase
				\item Maintenance Phase
				\item Retirement
			\end{itemize}
		\subsubsection{Requirements Phase}
			\begin{itemize}
				\item Determining the \textsc{needs} and \textsc{wants} of the client or customer.
				\item Determining the constraints of the system.
			\end{itemize}
		\subsubsection{Analysis or Specification Phase}
			\begin{itemize}
				\item After analyzing the requirements, construct a \emph{specification document} which explicitly describes what the product is to do, and the constraints under which it must operate.
				\item This includes the description of the input, output, actions, and UI.
				\item The specification document can be used as part of a contract with the client.
			\end{itemize}
			\paragraph{Problems with the Spec Document}
			\begin{enumerate}
				\item Ambiguity - one sentence may have more than one interpretation.
				\item Incompleteness - relevant fact or requirement is left out.
				\item Contradiction - two places in the spec document are in conflict.
			\end{enumerate}
		\subsubsection{Design Phase}
			\begin{itemize}
				\item Construct an \emph{Architectural Design}.
				\item Construct a \emph{Detailed Design}.
				\item Test for \emph{traceability}.
			\end{itemize}
			\begin{enumerate}
				\item \underline{Architectural Design} - Description of the product in terms of modules.
				\item \underline{Detailed Design} - Description of each module.
				\item \underline{Traceability} - each part of the design can be traced to a statement in the specification document.
			\end{enumerate}
		\subsubsection{Implementation Phase}
			\begin{itemize}
				\item Code each module from the detailed design.
				\item Programmer tests his/her own code separately.
				\item Modules are combined and tested by developers.
				\item Product is tested by SQA group. This is called product testing.
				\item Project is given to the client for acceptance testing.
			\end{itemize}
		\subsubsection{Maintenance Phase}
			\begin{itemize}
				\item Corrective Maintenance - bug squashing
				\item Enhancement Maintenance - Updates
				\begin{itemize}
					\item Perfective - client makes new demands
					\item Adaptive - changes in the environment of the product requires changes in the software.
				\end{itemize}
				\item Perform regression testing - insuring that changes have not affected already working functionality.
			\end{itemize}
		\subsubsection{Retirement Phase}
			\begin{itemize}
				\item Determining if desired changes are too costly.
				\item Determining if a product is obsolete.
			\end{itemize}
	\subsection{Four Components of the Software Engineering Enterprise}
	The four P's
	\begin{enumerate}
		\item Process
		\item Project
		\item People
		\item Product
	\end{enumerate}
		\subsubsection{Process}
			\begin{itemize}
				\item The process is sometimes called the life-cycle model or development sequence.
				\begin{itemize}
					\item Waterfall
					\item Spiral
					\item Incremental Build
				\end{itemize}
				\item Makes use of several process frameworks.
				\begin{itemize}
					\item Personal Software Process (PSP)
					\item Team Software Process (TSP)
					\item Capability Maturity Model (CMM)
				\end{itemize}
				\item Documentation Standards
				\begin{itemize}
					\item IEEE
					\item ANSI
				\end{itemize}
			\end{itemize}
		\subsubsection{Project}
			\begin{itemize}
				\item The set of activities needed to produce the required product.
				\item Project management is extremely important.
				\item Many projects are not about developing new products, but maintaining already existing \emph{legacy} systems.
			\end{itemize}
		\subsubsection{People}
			\begin{itemize}
				\item Team Organization
				\item Team Management
				\item Relationship with customer or client
				\item Relationship with end users
				\item Communication with upper management
			\end{itemize}
		\subsubsection{Product}
			Includes
			\begin{itemize}
				\item Requirement Specification Document
				\item Design Document
				\item Source Code
				\item Executable
				\item User Manuals
			\end{itemize}
	\chapter{Traditional Software Engineering Process}
		\subsection{Historical Influences}
			\begin{itemize}
				\item Structured programming (Edsger Dijkstra's letter calling "GOTOs" harmful) uses sequence control, iteration, invoking functions
				\item Object Oriented paradigm: the use of objects with data and functionality which can represent real-world entities.
			\end{itemize}
			\textit{Note:\\Silver Bullet ca. 1980s\\ Likened the software crisis to a werewolf.  Object Oriented Paradigm was the Silver Bullet.\\It did not work as expected.}
			\begin{itemize}
				\item Design Patterns: stock of reusable design elements (templates)
			\end{itemize}
		\subsection{Component Reuse}
			A component as defined by Meyer is "a program element satisfying:"
			\begin{enumerate}
				\item The element may be used by other program elements. (Clients)
				\item The clients and their authors do not need to be known to the element's author
			\end{enumerate}
		\subsection{Key Expectations of Software Engineering}
			\begin{enumerate}
				\item Decide in advance what the specific quality measures are to be for the project and product.\\
					\textit{Predetermine quantitative quality goals.}
				\item Gather data on all projects to form a basis for estimating future projects.
				\item All requirements, designs, code and test materials should be freely and easily available to all members of the team.\\
					\textit{Source code should always be available to all team members in an easily accessible and interpreted way.\\
								Git, Mercurial, etc.}
				\item A process should be followed by all team members. \textit{Uniformity}
					\begin{enumerate}
						\item Design only against requirements.
						\item Program only against design.
						\item Test only against requirements and design.\\
						\textsc{Always follow the recipe!}
					\end{enumerate}
				\item Measure and achieve quality goals.
			\end{enumerate}
	\section{Methods}
		\emph{Be able to draw and discuss these.}
		\subsection{Waterfall Method}
			\textsc{See diagram 52.9 on pg 53.}
			\begin{itemize}
				\item First described by William\textit{(?)} Royce in 1970.
				\item No phase is complete until documentation for that phase has been completed and approved by the SQA group.\\
					\textit{Very orderly; heavy on documentation.}
				\item Has been used with great success on a variety of products.
				\item Feedback loops permits modifications to be made to the previous phase.
			\end{itemize}
			\subsubsection{Advantages}
				\begin{enumerate}
					\item Enforced disciplined approach
					\item Requirement that documentation be provided at each phase.
					\item All products of the phase must be checked by SQA.
					\item Inherent aspect of each phase is testing.
				\end{enumerate}
			\subsubsection{Disadvantages}
				\begin{itemize}
					\item The resulting specification document may not be able to be understood by the client.
					\item It can lead to the construction of product that does not meet the client's needs.					
				\end{itemize}
		\subsection{Rapid Prototype Model}
			\textsc{See diagram on pg 55.}
			Construction of a functional subset of the desired product in order to allow the client and the developer to interact.\\
			\textit{Keyword is rapid.  This is a thrown-together, proof-of-concept type project; a mock-up.}
			\subsubsection{Advantages}
				\begin{itemize}
					\item The process is linear and possibly faster than the Waterfall Model
					\item Increases interaction between client and developer.
				\end{itemize}
			\subsubsection{Disadvantages}
				\begin{itemize}
					\item Client may inaccurately think the product is almost complete when viewing the prototype.
					\item Developer may attempt to use the prototype as part of the final product.
				\end{itemize}
		\subsection{Waterfall-Rapid Prototype Hybrid}
			May form a hybrid model using the rapid prototype as the first phase in the Waterfall Model in order to increase interaction but allow for feedback loops within the development of the product.
		\subsection{Incremental Model}
			Software is implemented, integrated, and tested as a series of incremental builds.\\
				\textit{Code pieces providing specific functions.}
			\subsubsection{Advantages}
				\begin{enumerate}
					\item Results in builds which can be developed in weeks, not months or years.
					\item End user need not learn the entire product at one time.
					\item Client need not pay for the entire product at one time.
					\item Developer gets paid earlier.\\ (At each build delivery)
					\item Open-ended design makes maintenance easier.
					\item Easier to make changes during development.
				\end{enumerate}
			\subsubsection{Disadvantages}
				\begin{enumerate}
					\item Each new build must fit in without destroying existing builds.\\
						\textit{Regression Testing}
					\item Requires more careful to design to make it open to additions.
					\item Can degenerate to a build and fix product if broken into too few builds.
				\end{enumerate}
		\subsection{Spiral Model}
			\textsc{See Figure 2.12 on pg 63 and Figure 2.13 on pg 65.}
			\begin{itemize}
				\item A Waterfall Model with each phase preceded by risk analysis in an attempt to control or resolve risk.
				\item Each phase is 360º.
				\item The measure of the radius is the cumulative cost to date.
				\item The measure of the angle is the progress measure.\\
					\textit{Each phase is 360º.\\
								Requires a very experienced engineer.}
			\end{itemize}
			\subsubsection{Advantages}
				\begin{enumerate}
					\item The emphasis on alternatives and constraints supports the reuse of existing software.
					\item The incorporation of software quality as a specific objective.
					\item Answers the question of how much testing should be performed in terms of risks.
					\item Maintenance is simply another cycle of the spiral, the same as development.
				\end{enumerate}
			\subsubsection{Disadvantages}
				\begin{enumerate}
					\item Intended exclusively for internal development.\\
						\textit{Client and developer are members of the same organization.}
					\item \emph{Applicable only to large-scale projects.}
					\item Must have developers who are skilled at pinpointing the possible risks.
				\end{enumerate}
		\section{Agile Methods}
			\subsection{General}
				According to the Agile Manifesto, they value:
				\begin{itemize}
					\item Individuals and interactions over processes and tools.
					\item Working software over comprehensive documentation.
					\item Customer collaboration over contract negotiation.
					\item Responsiveness to change over following a plan.\\
						\textsc{You don't always have to follow the recipe!}
				\end{itemize}
				\subsubsection{Traits}
					\begin{itemize}
						\item Highly iterative
						\item Pair programming with a focus on teamwork and ego-less programming.\\
							\textsc{This is mandatory.}
						\item Early and planned testing.
						\item Story cards \textit{Similar to storyboards in movies.}
						\item Refactoring \textit{Turning working code into better code.}
						\item Feedback
					\end{itemize}
				\subsubsection{Principles Behind the Agile Manifesto}
					\begin{enumerate}
						\item Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
						\item Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive disadvantage.
						\item Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.
						\item Business people and developers must work together daily throughout the project.
						\item Build projects around motivated individuals. Give them the environment and support they need and trust them to get the job done.
						\item The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
						\item Working software is the primary measure of progress.
						\item Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
						\item Continuous attention to technical excellence and good design enhances agility.
						\item Simplicity - the art of maximizing the amount of  work not done - is essential.
						\item The best architectures, requirements, and designs emerge from self-organizing teams.
						\item At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.
					\end{enumerate}
			\subsection{Refactoring}
				\begin{itemize}
					\item Reduce software complexity
					\item Improve internal structure while preserving the behavior of the code.\\
						\textit{Prettifying}
					\item Improve software quality\\
						\textit{Readability, execution efficiency, size efficiency, etc.}
					\item Performed in response to "bad smells" in the code, undesirable characteristics\\
						\textit{Martin Fowler}
					\item Automated or manual\\
				\end{itemize}
	\chapter{Teams}
		\underline{Team} - a group of professionals organized in order to complete the task of creating a large software project.
		\section{Team Structure}
			\subsection{Project Factors Related to Structure of the Team}
				\begin{enumerate}
					\item Difficulty of the problem
					\item Size of the program in LOC or Function Points\\
						\textit{LOC stands for Lines of Code}
					\item Time the team will stay together
					\item Degree of modularity for program
					\item Required quality and reliability
					\item Rigidity of delivery date
					\item Degree of communication required
				\end{enumerate}
			\subsection{Jelled Team}
				\begin{itemize}
					\item A group of people which are so tightly knit that the attitude is that the whole is greater than the sum of the parts
					\item Egos are forgotten and the team becomes important
					\item Exhibits cohesiveness, team spirit, common definition of success
					\item Generally more productive, more motivated, and happier
				\end{itemize}
			\subsection{Why Don't All Teams Jell?}
				\begin{itemize}
					\item A frenzied work atmosphere
					\item High frustration causing friction among team members
					\item A "fragmented or poorly coordinated" software process
					\item An unclear definition on the team
					\item "Continuous and repeated exposure to failure" - M. Jackman \textit{Homeopathic Remedies for Team Toxicity}
				\end{itemize}
			\subsection{Necessary Team Traits}
				Personality
				\begin{itemize}
					\item Openness - intellectual curiosity
					\item Conscientiousness - self-discipline, pushing toward goals
					\item Extroversion - energy, emotions, seek company of others\\
						\textit{Being a people person}
					\item Agreeableness - compassionate and cooperative
					\item Neuroticism - how a person responds to stress, emotional stability
				\end{itemize}
			\subsection{How to Make Personality Traits Work}
				\begin{enumerate}
					\item Recognize people have different types of personalities
					\item Assemble a diverse team covering a range of personalities
					\item Create an open, honest, tolerant atmosphere in team meetings
				\end{enumerate}
		\section{Roles}
			\begin{itemize}
				\item \underline{Team Leader} - Responsible for overseeing all aspects of the team project; holds the tie-breaking vote.
				\item \underline{Technical Lead} - Expert on all technical aspects of the project, in particular the hardware and software used for development.
				\item \underline{Designer} - Designs the project and breaks the project into smaller pieces (\textit{Modules}) for the programmers.
				\item \underline{Lead Programmer} - Needs to have an understanding of the project as a whole; organizes all of the other programmers.
				\item \underline{Technical Writer} - Writes all documentation for the project (\textit{Team meeting minutes, Specification Document, Users' Manual})
				\item \underline{Configuration Management} - Maintains the code base for the project; could include CVS responsibilities.
				\item \underline{Quality Assurance} - Writes, maintains, and conducts all testing associated with the project.
			\end{itemize}
		\section{Organizational Structures}
			\begin{itemize}
				\item Democratic Team
				\item Hierarchical or Chief Programmer
				\item Team Manager/Team Leader
				\item Synchronize-and-Stabilize Team
				\item Agile Team
			\end{itemize}
			\subsection{Democratic Team}
				\begin{itemize}
					\item Group of up to 10 programmers
					\item Equal partnership with egoless programming
					\item Works well if the group is small, highly competent
					\item Problem with who is in charge
					\item Positive attitude about finding fault
					\item Good in research environment with difficult problem
				\end{itemize}
			\subsection{Hierarchical or Chief Programmer}
				\begin{itemize}
					\item One overall manager (\textit{Chief Programmer})
					\item Everyone understands the lines of authority\\
						\textit{One boss.}
					\item Team members tend to participate less in decisions; decisions are handed down from above
					\item May have a Programming Secretary and a Backup Programmer for the Chief Programmer
					\item Difficult to find one person adept at both managing and programming.
				\end{itemize}
			\subsection{Team Manager/Team Leader}
				\textit{See Figure 4.4, pg. 114}
				\begin{itemize}
					\item Split the responsibilities of Chief Programmer into Team Manager and Team Leader
					\item The Team Manager handles the nontechnical management
					\item The Team Leader deals with the technical issues of the project
					\item Results in programmers having two bosses
					\item May be difficult to determine if an issue is technical or nontechnical
				\end{itemize}
				\paragraph{Technical Organizational Structure for Large Projects}
					\begin{itemize}
						\item One Project Leader oversees several team leaders
						\item Each team leader has several programmers for which he/she is responsible
						\item Clear lines of communication\\
							\textit{Two level structure}
					\end{itemize}
			\subsection{Synchronize-and-Stabilize Team}
				\textit{Has been used by Microsoft}
				\begin{itemize}
					\item Small team led by a manager and having three to eight developers and three to eight testers working one-to-one with the developers
					\item Developers are given freedom to design and implement their portions as they wish
					\item Each day, the partial components are tested and debugged.
					\item Encourages creativity and innovation yet the daily synchronization keeps the project on track.
				\end{itemize}
			\subsection{Agile Team}
				\begin{itemize}
					\item Work in pairs (\textsc{Mandatory})
					\item Provide instant review
					\item Create test cases which are used for daily testing
					\item Remove the problem if one developer leaves, the knowledge does not disappear about a portion of the project
				\end{itemize}
	\chapter{Tools}
		\section{Tools for Software Engineers} 
			\begin{itemize}
				\item  Analytic (Theoretical) Tools:
					\begin{enumerate}
						\item  Stepwise Refinement
						\item Cost-Benefit Analysis
						\item Divide-and-Conquer
						\item Separation of Concerns
						\item Software Metrics
					\end{enumerate}
				\item Software Tools (CASE: Computer-Aided Software Engineering)
			\end{itemize}
			\subsection{Analytic Tools}
				\subsubsection{Stepwise Refinement}
					\begin{itemize}
						\item Process whereby a project is successively decomposed into more detailed instructions.
						\item In each step, a given task is written as a set of subtasks.
						\item Term was first coined by Niklaus Wirth in 1971.
						\item Helps to concentrate on relevant aspects of the current development phase and ignore details that need not be considered.
						\item A postponement of decisions on details until as late as possible.
						\item Critical to object-oriented paradigm.
					\end{itemize}
				\subsubsection{Cost-Benefit Analysis}
					\begin{itemize}
						\item Comparing estimated future benefits against future costs for a certain decision.
						\item Problems occur in that intangible benefits may be hard to quantify.
						\item May use past experience to project the estimates for benefits or costs.
					\end{itemize}
				\subsubsection{Divide-and-Conquer}
					\begin{itemize}
						\item Most agree this is the oldest analytical tool used in Software Engineering.
						\item Break a large problem into smaller subprograms that should be easier to solve.
						\item Idea used in the Unified Process.
						\item Good concept but no details in the how... \textsc{GET THIS BULLET}
						\item \textit{Key difference from Stepwise Refinement is that Divide-and-Conquer does not necessarily procrastinate details.}
					\end{itemize}
				\subsubsection{Separation of Concerns}
					\begin{itemize}
						\item First introduced by Dijkstra in 1974.
						\item Process of breaking a software project into components which overlap as little as possible in relationship to functionality.
						\item Regression faults are minimized.\\
							\textit{If every component does one function (High Cohesion), making changes won't affect a lot of things.}
						\item Components are more reusable.
					\end{itemize}
				\subsubsection{Software Metrics}
					Measurements used to indicate:
					\begin{itemize}
						\item Size (LOC - Lines of Code)
						\item Duration (Months, years)
						\item Effort (Person-Months)
						\item Quality (Fault Density - Faults/1000LOC)
						\item Efficiency (Faults/Unit of time)
						\item Reliability (Mean time between failures)
					\end{itemize}
					Product/Process
			\subsection{CASE Tools}
				\begin{itemize}
					\item UpperCASE or front-end tools - used in the requirements, analysis and design workflows
					\item LowerCASE or back-end tools - used in the implementation and maintenance activities
				\end{itemize}
				\subsubsection{Types of CASE Tools}
					\begin{itemize}
						\item Data Dictionary - computerized list of all data defined within the product (type and location defined)\\
							\textit{Could be Upper or LowerCASE}
						\item Consistency Checker - tool which checks that everything in the design is in the specification document and everything in the specification document is in the design.
						\item Report Generator - tool which generates code needed for producing a report.
						\item Screen Generator - tool which generates the code necessary for a data capture screen.
						\item Structured Editor - a text editor which is designed to understand the structure of a program in a programming language, aiding in syntax fault prevention or early detection.
						\item Pretty Printer or Formatter - code often included with the structured editor which makes use of the language syntax structure to display the code in a standard manner (indenting, highlighting reserved words or comments)\\
							\textit{Try Sublime Text 2!}
						\item On-line Interface Checker - editor know every subprogram declared within the product and their parameter lists.
						\item Operating System Front End - tool which allows the programmer to give commands to the operating system from within the editor.
						\item Source Level Debugger \textit{LowerCASE}
						\item Interactive Source Level Debugger \textit{LowerCASE}
						\item Version Control Tool - keeps detailed record of each version of the project.\\
							\textit{Check out Git with GitHub or BitBucket!}
						\item Configuration Control Tool - manages multiple variations. \textit{LowerCASE}
					\end{itemize}
				\subsubsection{Grouped CASE Tools}
					\begin{itemize}
						\item CASE Workbench - collection of CASE tools that together support one or two activities.
						\item CASE Environment - collection of CASE tools which support the entire software process.
					\end{itemize}
		\section{Software Versions}
			\begin{itemize}
				\item During maintenance, at least two versions of the product will exist: the old version and the new version.
				\item \underline{Revision} - what we call the new version.
				\item \underline{Configuration} - the specific version of each artifact from which a given version of the complete product is built.
			\end{itemize}
	\chapter{UNIFIED PROCESS - I'm not sure what to put here.}
		\section{Phases of Unified Process}
			\subsection{Inception Phase}
				\begin{itemize}
					\item Determine whether it's worthwhile to develop the target product
					\item Determine economic viability
					\item Steps
						\begin{enumerate}
							\item Obtain domain knowledge
							\item Build business model\\
								\textit{Understand how the client operates within the domain.}
						\end{enumerate}
				\end{itemize}
				Questions to consider:
				\begin{enumerate}
					\item Is the proposed software cost effective?
					\item Can the proposed software be delivered on time?
					\item What risks are involved in developing the software and how can these risks be mitigated?
				\end{enumerate}
				Identify Risks
				\begin{enumerate}
					\item Technical risks
					\begin{itemize}
						\item Necessary experience?
						\item New hardware needed and will it be delivered on time?
						\item Software tools needed?
					\end{itemize}
					\item Not getting the requirements right
					\item Not getting the architecture (design) right
				\end{enumerate}
				\subsubsection{Documentation in the Inception Phase}
					\begin{itemize}
						\item Initial version of the domain model
						\item Initial version of the business model
							\textit{How the client operates in their domain.}
						\item Initial version of the requirements artifacts
						\item Preliminary version of the analysis artifacts
						\item Preliminary version of the architecture
						\item Initial list of risks
						\item Initial use cases
						\item Plan for elaboration phase
						\item Initial version of the business case\\
							\textit{Document that describes the cost-effectiveness of taking on the project}
					\end{itemize}
			\subsection{Elaboration Phase}
				\begin{itemize}
					\item The aim is to refine the requirements, refine the architecture, monitor the risks, refine the business case, and produce the software project management plan.
					\item Major activities are refinements of the previous phase.
				\end{itemize}
				\subsubsection{Elaboration Phase Deliverables}
					\begin{itemize}
						\item Completed domain model
						\item Completed business model
						\item Completed requirements artifact
						\item Completed analysis artifacts
						\item Updated version of the architecture
						\item Updated list of risks
						\item Software Project Management Plan (SPMP)
						\item Completed business case
					\end{itemize}
			\subsection{Construction Phase} 
				\begin{itemize}
					\item Aim is to produce the first operational-quality version of the product (beta release)
					\item Emphasis is on implementation and testing
					\item Components are coded and unit tested
					\item Components are combined (integrated) and tested again.
				\end{itemize}
				\subsubsection{Construction Phase Deliverables}
					\begin{itemize}
						\item Initial user manual and other manuals as needed
						\item All the artifacts of the beta release version
						\item Completed architecture
						\item Updated risk list
						\item Software Project Management Plan (SPMP)
						\item Updated business case if needed
					\end{itemize}
			\subsection{Transition Phase}
				\begin{itemize}
					\item Aim is to ensure that the client's requirements have been met
					\item Driven by feedback from the locations where the beta version is installed and tested
					\item Manuals are completed
					\item Faults are corrected
					\item Discover any unidentified risks
				\end{itemize}
				\subsubsection{Transition Phase Deliverables}
					\begin{itemize}
						\item All the artifacts of the final version
						\item Completed manuals
					\end{itemize}
					Refer to pg. 88 of the book.
	\chapter{Testing}
		\underline{Testing} - continual process carried on during the entire life cycle of software.\\
		\paragraph{V and V}
			\begin{itemize}
				\item Verification - determining whether a phase has been correctly carried out (at the end of the phase) 
				\item Validation - testing just before a product is delivered to the client to determine if it satisfies the specifications
			\end{itemize}
		\paragraph{Use of the Term Testing}
			We use the term testing instead of V and V because they imply that testing can wait until certain points in the process like the end of a phase, when testing must occur throughout the process.
			\subsection{Fault, Failure, Error, Defect}
				\begin{itemize}
					\item Fault - human mistake created in software
					\item Failure - observed incorrect behavior due to a fault
					\item Error - amount by which a result is incorrect 
					\item Defect - generic term used to encompass fault, failure, and error
				\end{itemize}
		\section{Software Quality}
			\begin{itemize}
				\item Extent to which the product satisfies its specifications
				\item Adherence to specifications
				\item Must be ensured at all times, not just added at the end of the product
				\item Every software developer must be personally responsible for the quality of their work.
			\end{itemize}
			\subsection{Software Quality Assurance}
				SQA group oversees the quality throughout the process
				\begin{itemize}
					\item Adherence to standards
					\item Correctness of each workflow
					\item Independent of the development team
				\end{itemize}
			\subsection{Categories of Testing}
				\begin{enumerate}
					\item Non-Execution-Based Testing (Reviews)
						\begin{itemize}
							\item Walkthroughs
								\begin{itemize}
									\item 4-6 person team  (Experience Senior Staff)
									\begin{itemize}
										\item Manager of the current workflow
										\item Member of the team on the current workflow
										\item Member of the team on the subsequent workflow
										\item Client Representative
										\item SQA group member
									\end{itemize}
									\item Material distributed to allow participants to prepare
									\item Each reviewer develops two lists: things they don't understand, things they think are incorrect
									\item Purpose is to find faults in a workflow or document such as the specification or the design document and create a list of faults for later correction
									\\\\
									Ways to conduct a walkthrough
									\begin{enumerate}
										\item Participant Driven - members present their lists to the team creating the document being tested which respond to each item (clarify questions, repair faults)
										\item Document Driven - chair walks the members through the document with stops at the unclear or possible faults
									\end{enumerate}
								\end{itemize}
							\item Inspections
								\begin{itemize}
									\item Proposed by Fagan in 1976 for testing designs and 
									\item Consists of five formal steps
									\item Conducted by team of size 4-5
										\begin{itemize}
											\item Moderator - both manager and leader of the inspection team
											\item Reader - leads team through the document
											\item Recorder - produces written report of detected faults
											\item Implementer/Tester
										\end{itemize}
									\item Steps:
										\begin{enumerate}
											\item Overview - presentation by one individual responsible for producing it after which given to participants
											\item Preparation - participants try to understand the document using lists of fault types and create checklist
											\item Inspection - one participant walks through using the checklists with the moderator creating a written report
											\item Rework - using the written report of faults, the individuals which created the document resolve the faults
											\item Follow-Up - moderator makes sure that everything in the report has been corrected or addressed and that no new faults were created in repairing the original faults
										\end{enumerate}
								\end{itemize}
						\end{itemize}
						\paragraph{Comparison of Walkthroughs and Inspections}
							\begin{itemize}
								\item Walkthroughs are 2 steps and inspections are more formal 5 steps 
								\item Inspections generally take longer but the extra time and effort spent can be cost effective
							\end{itemize}
					\item Execution-Based Testing
				\end{enumerate}
		\section{Reviews}
			\subsection{Strengths of Using Reviews}
				\begin{enumerate}
					\item Effective way to find faults in the specification document or the design document.
					\item Faults detected earlier in the process are less costly to repair or remove.
				\end{enumerate}
			\subsection{Metrics for Inspections}
				\begin{enumerate}
					\item Inspection Rate - the number of pages inspected per hour (for specifications and designs) or lines of code inspected per hour (for code inspection)
					\item Fault Density - number of faults per page or number of faults per KLOC
					\item Fault Detection Rate - number of major and minor faults detected per hour
					\item Fault Detection Efficiency - number of major and minor faults detected per person-hour
				\end{enumerate}
				These methods are used to determine whether the inspection process is working.
			\paragraph{Goals and Limits of testing}
				\begin{itemize}
					\item Goal: To maximize the number and severity of defects found per dollar spent
					\item Limit: Testing can only determine the presence of defects, never their absence. Correctness proofs are the only manner of proving the absence of defects.
				\end{itemize}
			\subsection{Levels of Testing}
				\begin{enumerate}
					\item Unit Testing - The earliest type of testing, testing the parts of the application (functions, modules, module combinations)
					\item Integration Testing - Validates the overall functionality of each stage
					\item Acceptance Testing - Validates the final product
				\end{enumerate}
			\subsection{Steps for Unit Testing}
				\begin{enumerate}
					\item Plan the general approach, resources, and schedule.
					\item Determine requirements-based characteristics to be tested.
					\item Refine the general plan.
					\item Design the set of tests.
					\item Implement the refined plan and design.
					\item Execute the test procedures.
					\item Check for termination.
				\end{enumerate}
			\subsection{Test Types}
				\begin{itemize}
					\item Black Box - Check correct output for given input as specified by the requirements
					\item White Box (or Clear Box) - Design test of cover all paths through the application.
					\item Gray Box - Consider limited details of the application with some of the Black Box techniques.
				\end{itemize}
				\subsubsection{Black Box Testing}
					\begin{itemize}
						\item Equivalence Partitioning - Division of the test input data into subsets
						\item Boundary Value Analysis - Testing for values which separate acceptable and unacceptable ranges.
					\end{itemize}
				\subsubsection{White Box Testing}
					\begin{itemize}
						\item Statement Coverage - Every statement should be executed by at least one test.
						\item Decision Coverage - Every branch of decision statements is executed.
					\end{itemize}
			\subsection{Planning Unit Tests}
				\begin{enumerate}
					\item Decide what the units are to be and who will test them.
					\item Decide how unit tests will be documented.
					\item Determine the extent of unit testing.
					\item Decide how and where to get the test input.
					\item Estimate the resources required.
					\item Arrange to track time, number, type, and source of defects.
				\end{enumerate}
			\subsection{Unit Testing of Methods}
				\begin{enumerate}
					\item Verify operation at normal parameter values.
					\item Verify operation at limit parameter values.
					\item Verify operation outside parameter values.
					\item Ensure that all instructions execute.
					\item Check all paths - both sides of branches.
					\item Check the use of all called objects.
					\item Verify the handling of all data structures.
					\item Verify the handling of all files.
					\item Check normal termination of all loops.
					\item Check abnormal termination of all loops.
					\item Check normal termination of all recursion.
					\item Check abnormal termination of all recursion.
					\item Verify the handling of all error conditions.
					\item Check timing and synchronization.
					\item Verify all hardware dependencies.
				\end{enumerate}
			\subsection{Class Testing}
				\begin{enumerate}
					\item Method Combination test
					\item Attribute-Oriented Test
					\item Testing Class Invariants
					\item State-based Tests
				\end{enumerate}
			\subsection{What is Tested During Execution Based Testing?}
				\begin{itemize}
					\item Utility - How useful it is or how it meets the needs of the user
					\item Reliability - Measuring the mean time between failures; reliable software rarely fails
					\item Robustness - valid output for valid input, error conditions handled correctly (satisfying the specifications)
					\item Performance - How well it meets the constraints
					\item Correctness - Valid output for valid input
				\end{itemize}
	\chapter{Modules and Objects}
		\section{Modules}
			Lexically contiguous sequence of statements bounded by boundary symbols, having an associated name.
			\paragraph{Cohesion and Coupling}
				\begin{itemize}
					\item \underline{Cohesion} - Measures of software quality relating to modules or classes.
					\item \underline{Coupling} - Measures used to quantify characteristics like reusability, reliability, etc.
				\end{itemize}
			\subsection{Cohesion}
				\begin{itemize}
					\item The degree of interaction within a module
					\item A description of the logical relationship between elements of a class
					\item The type of relationship that exists among the elements of each software entity.
				\end{itemize}
				\subsubsection{Types of Cohesion}
					\begin{enumerate}
						\item \underline{Coincidental} - No meaningful relationships among the elements of an entity. Difficult to describe the module's function(s)
						\item \underline{Logical} - Performs a series of related actions, one of which is selected by the calling module.
						\item \underline{Classical or Temporal} - Performs a series of actions related in time
						\item \underline{Procedural} - Performs a series of actions related by the sequence of steps to be followed by the product.
						\item \underline{Communicational} - Performs a series of actions related by the sequence of steps to be followed by the product performed on the same data.
						\item \underline{Informational} - Performs multiple functions, each with its own entry point, with independent code for each action, all performed on the same data structure.
						\item \underline{Functional} - Performs a single function or action.
					\end{enumerate}
					\textit{(Note: \#3-5 are sometimes called Flowchart Cohesion.)}
				\paragraph{Notes on Cohesion}
					\begin{itemize}
						\item As the cohesion number increases, so do the cohesion level and the desirability.
						\item Functional cohesion enhances reusability.
						\item Maintenance is easier to perform on a module with functional cohesion.
					\end{itemize}
			\subsection{Coupling}
				\begin{itemize}
					\item The degree of interaction between two modules.
					\item The type of relationship that exists between two software entities.
				\end{itemize}
				\subsubsection{Types of Coupling}
					\begin{enumerate}
						\item \underline{Content} - One software entity references the contents of another entity
						\item \underline{Common} - Software entities reference a shared global data structure
						\item \underline{External} - Software entities reference the same externally declared symbol
						\item \underline{Control} - One entity passes control elements as arguments to another entity
						\item \underline{Stamp} - A data structure is passed but not entirely used.
						\item \underline{Data} - One entity calls another and are not coupled as described above (every parameter passed is simple or a data structure entirely used)
					\end{enumerate}
			\subsection{Abstraction}
				\begin{enumerate}
					\item Data Abstraction
					\item Procedural Abstraction
				\end{enumerate}
				A means of achieving stepwise refinement by suppressing unnecessary details and accentuating relevant details.
			\subsection{Data Encapsulation}
				\begin{itemize}
					\item Data structure along with the actions or operations to be performed on that structure
					\item An example of abstraction
				\end{itemize}
				\subsubsection{Procedural Abstraction}
					Conceptualizing in terms of giving a name to a set of high-level actions which are specified by the body of the procedure.
				\subsubsection{Information Hiding}
					\begin{itemize}
						\item Better named "detail hiding"
						\item Concept introduced by Parnas
						\item Hiding the implementation details of a module from another using it
					\end{itemize}
				\subsubsection{Abstract Data Type (ADT)}
					\begin{itemize}
						\item Specification of a data type along with the operations on that type
						\item Supports both data and procedural abstraction
					\end{itemize}
				\subsubsection{Three Concepts Important to the OO Paradigm}
					\begin{enumerate}
						\item Inheritance*
						\item Polymorphism*
						\item Dynamic Binding
					\end{enumerate}
					\textit{* - These are especially important}
	\chapter{Reusability and Portability}
		\section{Reuse}
			\underline{Reuse} - Taking components of one product to be used in a different product with different functionality
			\subsection{Types of Reuse}
				\begin{enumerate}
					\item \textbf{Accidental} or \textbf{Opportunistic} Reuse - Developers realize that a component from a previously constructed product can be reused in the new project on which they are currently working.
					\item \textbf{Deliberate} or \textbf{Systematic} Reuse - Components are constructed with the purpose that they will be reused
				\end{enumerate}
				\subsubsection{Advantages of Deliberate Reuse}
					\begin{itemize}
						\item Components will be constructed with reuse in mind will be:
							\begin{itemize}
								\item more likely to be easier and safer to use.
								\item better documented.
								\item more thoroughly tested.
								\item adhere to a uniformity of style.
								\item more easily maintained.
							\end{itemize}
					\end{itemize}
				\subsubsection{Disadvantages of Deliberate Reuse}
					\begin{itemize}
						\item Can be expensive to the company
						\item Can be more time consuming
							\begin{itemize}
								\item Design
								\item Testing
								\item Documentation
							\end{itemize}
						\item May not be reused after time spent making it reusable
					\end{itemize}
			\subsection{Impediments to Reuse}
				\begin{enumerate}
					\item Ego
					\item Uncertainty of quality\\
						\textit{(Distrust of others' abilities)}
					\item Economic Reasons\\
						\textit{Afraid you might lose your job/Company won't need you anymore}
					\item Retrieval\\
						\textit{Can't find it}
					\item Expense\\
						\textit{To the company}
					\item Legality
					\item For COTS (\textit{Commercial Off-the-Shelf}) components - limited extensibility/modifiability
				\end{enumerate}
				May occur during design as well as implementation
			\subsection{Types of Design Reuse}
				\begin{enumerate}
					\item Company that develops software in one specific domain may set up repository of design components. (Library/Toolkit)
						\begin{enumerate}
							\item Tested module designs incorporated
							\item Reduce design time (and likely implementation)
							\item Increase design quality
						\end{enumerate}
					\item Application Frameworks
					\item Design Patterns
					\item Software Architecture
				\end{enumerate}
		\section{Design Patterns}
			\begin{itemize}
				\item Christopher Alexander - "Each pattern describes a problem which occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice."
				\item Each design pattern is a solution to a general problem in the form of a set of interacting classes that have to be customized to create a specific design.
				\item Four Essential Elements
					\begin{enumerate}
						\item Pattern name
						\item Problem it solves
						\item Solution - elements making up the design
						\item Consequences - results and trade offs of applying	
					\end{enumerate}
			\end{itemize}
			\subsection{List of Design Patterns}
				\begin{enumerate}
					\item Abstract Factory
					\item Adapter
					\item Bridge
					\item Builder
					\item Chain of Responsibility
					\item Command
					\item Composite
					\item Decorator
					\item Façade
					\item Factory Method
					\item Flyweight
					\item Interpreter
					\item Iterator
					\item Mediator
					\item Memento
					\item Observer
					\item Prototype
					\item Proxy
					\item Singleton
					\item State
					\item Strategy
					\item Template Method
					\item Visitor
				\end{enumerate}
		\section{Portability}
			Software which is significantly easier to modify to run on another platform than it is to code from scratch.
			\subsection{Impediments to Portability}
				\begin{enumerate}
					\item Hardware Incompatibilities
					\item Operating System Incompatibilities
					\item Difference in numeric capabilities (\textit{32-bit v. 64-bit})
					\item Compiler Incompatibilities
					\item Data Formats
				\end{enumerate}
	\chapter{Planning and Estimating}
		\section{Cost}
			\subsection{Cost Estimation}
				Can occur at:
					\begin{itemize}
						\item Conceptualization Phase
						\item Requirements Analysis
						\item Design Phase
						\item Implementation Phase
						\item Implementation and Testing
					\end{itemize}
			\subsection{Cost Types}
				\begin{itemize}
					\item Internal Cost - cost to developer
						\begin{itemize}
							\item Salaries
							\item Hardware Support
							\item Software Support
						\end{itemize}
					\item External Cost - ???
				\end{itemize}
		\section{Size}
			\paragraph{Metrics for Size}
				\begin{enumerate}
					\item LOC - Lines of Code
					\item KDSI - Thousand Delivered Source Instructions
					\item Number of Operands and Operators
					\item FFP - Files, Flows, and Processes
					\item FP - Function Points
				\end{enumerate}
			\subsection{LOC and KDSI}
				\subsubsection{Problems With Using LOC or KDSI}
					\begin{enumerate}
						\item Creation of source code is only small part of total effort
						\item Same product in different languages would have different LOC
						\item Some languages have no concept of a line of code (LISP)
						\item Question as to whether only to count executable statements (omit declarations, comments, JCL (Job Control Language), reused code?)
						\item Not all code that is written is delivered
						\item Must wait until the project is finished to get the measurement
						\item Code generation tools
					\end{enumerate}
			\subsection{FFP}
				\begin{itemize}
					\item \underline{File} - collection of logically or physically related records, permanently resident in the product (transaction and temporary files do not count here)
					\item \underline{Flow} - data interface between the product and the environment (screen or report)
					\item \underline{Process} functionally defined logical or arithmetic manipulation of the data (sorting, validating, updating, etc.)
				\end{itemize}
			\subsection{FP}
				\underline{Function Points} - used to assess the size of a project
				\begin{enumerate}
					\item Identify the functions the application must have.
					\item For each function, compute:
						\begin{enumerate}
							\item External Inputs - EI
							\item External Outputs - EO
							\item External Inquiries - EIN
							\item Internal Logical Files - ILF
							\item External Logical Files - ELF
						\end{enumerate}
					\item Multiply the numbers from step 2 by specified values (see p. 274) This results in an unadjusted function point value (UFP).
					\item Compute the Technical Complexity Factor (TCF) using the effect of the 14 general characteristics of the project which have been assigned a value from 0-\textit{not present or no influence} to 5-\textit{strong influence throughout}. The 14 numbers are summed using the Total Degree of Influence (DI). Then the TCF is given by .65+.01*DI (see p.274)
					\item FP = UFP * TCF
				\end{enumerate}
				\subsubsection{Converting Function Points to Code}
					Once the function point value is computed, an estimate for the lines of code by multiplying by a constant associated with the language we plan to use for the application.
				\subsubsection{Techniques for Estimation of Size}
					\begin{itemize}
						\item Use comparisons with past jobs
						\item Use function point methods
							\begin{itemize}
								\item Compute unadjusted function points
								\item Apply adjustment process
							\end{itemize}
						\item Use LOC estimates to compute labor and duration using COCOMO formulas.
						\end{itemize}
			\subsection{COCOMO}
				\begin{itemize}
					\item Estimation method devised by Boehm in 1981
					\item COnstructive COst MOdel
					\item Depends on the LOC of a project
					\item 
				\end{itemize}
		\section{Cost Estimation Techniques}
			\begin{enumerate}
				\item Expert Judgment by Analogy - Consult a number of experts who have completed similar type projects.
				\item Bottom-up - Estimate each component from the leaf level and add, going upward in design.
				\item Algorithmic Cost Estimation - Use FF or FP and comu.
			\end{enumerate}
			\subsection{Software Project Management Plan
				\begin{itemize}
					\item Plan which describes the proposed software development in full detail. (\textit{See p. 285})
					\item Consists of three main components:
					\begin{enumerate}
						\item The work to be completed
						\item The resources to be used to do the work
						\item Funding
					\end{enumerate}
				\end{itemize}}
				\subsubsection{Work to be Completed}
					\begin{enumerate}
						\item Project function - work which continues throughout the project and is not related to any specific workflow.
						\item Activity - work which is related to a specific phase or workflow and has a definite beginning and end date
					\end{enumerate}
				\subsubsection{Resources}
					\begin{enumerate}
						\item People (varies during the duration of the project)
						\item Hardware
						\item Support Software (include CASE tools)
					\end{enumerate}
\part{Useful Information}
	\chapter{Test 1}
		\begin{itemize}
			\item Draw and discuss waterfall and life-cycle model
		\end{itemize}
	\chapter{Agile Presentations}
		\section{Kanban}\\
			\textit{Ankur Patel}
			\begin{itemize}
				\item Japanese for 'Visual Card'
				\item David Anderson, 2004-2007
				\item Kanban method was originally created by Taiichi Onho in the late 1940s.
				\item Implement business concept of JIT at TPS\\
					\textit{Anderson adapted it to software}
				\item Lots of whiteboards, sticky notes, and sections of each software dev cycle to increase visibility of workflow.
				\item Columns and subcolumns
					\begin{itemize}
						\item Columns for phases
						\item Subcolumns for 'To-Do', 'Doing', 'Done'
					\end{itemize}
				\item Bottlenecks the team's efforts.
				\item Flexible
			\end{itemize}
		\section{Agile Scaling Model}\\
			\textit{Cody Herring}
			\begin{itemize}
				\item Way of beginning the software development process.
				\item Scott Ambler
				\item Three Categories
					\begin{itemize}
						\item Core Agile Development
							\begin{itemize}
								\item Beginning role in the development cycle
							\end{itemize}
						\item Agile Delivery
							\begin{itemize}
								\item Repeatable results with just the right amount of ceremony for the situations they face.
							\end{itemize}
						\item Agile at Scale
					\end{itemize}
				\item First step to take
					\begin{itemize}
						\item Adopt disciplined agile delivery life cycle
					\end{itemize}
				\item Complementary strategy to other methodologies
			\end{itemize}
		\section{Agile Software Development}\\
			\textit{Jared Cox}
			\begin{itemize}
				\item James Highsmith and Sam Bayer
				\item Came from RSD
					\begin{itemize}
						\item Like RSD, but more iterative
					\end{itemize}
				\item Six Characteristics
					\begin{itemize}
						\item Mission-driven
						\item Component-based
						\item Iterative
						\item Time-boxing
						\item Risk-driven
						\item Change-tolerant
					\end{itemize}
				\item Three Step Life Cycle
					\begin{itemize}
						\item Speculate
						\item Collaborate
						\item Learn
					\end{itemize}
			\end{itemize}
		\section{Crystal Methods}\\
			\textit{James Reatherford}
			\begin{itemize}
				\item Alistair Cockburn
				\item Series of related methods for projects of various size and complexity
				\item Incremental
				\item Real crystals have two main properties: color and hardness
				\begin{itemize}
					\item Color - size of team
					\item Hardness - complexity of the project in terms of cost of failure
				\end{itemize}
				\item Very much like agile manifesto
			\end{itemize}
		\section{Crystal Clear}\\
			\textit{Ashutosh Karki}
			\begin{itemize}
				\item Lowest hardness of Crystal Family
				\item Osmotic communication
				\item Optimized
			\end{itemize}
		\section{Agile Modeling}\\
			\textit{CJ Stokes}
			\begin{itemize}
				\item Scott Ambler
				\item Values
					\begin{itemize}
						\item Communication
						\item Simplicity
						\item Feedback
						\item Courage
						\item Humility
					\end{itemize}
				\item Principles
					\begin{itemize}
						\item Software is primary
						\item Enabling the next effort is secondary
						\item Travel light
						\item Assume simplicity
						\item Embrace change
						\item Incremental change
						\item Model with a purpose
						\item Multiple models
						\item Quality work
						\item Rapid feedback
					\end{itemize}
				\item Practices
					\begin{itemize}
						\item Iterative and Incremental Modeling
						\item Teamwork
					\end{itemize}
			\end{itemize}
		\section{Extreme Programming}
			\subsection{Phillip Clark}
				\begin{itemize}
					\item Kent Beck
					\item Heavily based on test-driven development and iterative and incremental development
					\item Takes common sense principles to an extreme level
					\item Coding is the key activity.
					\item System architecture is not documented (The code is the documentation)
					\item Four values
						\begin{enumerate}
							\item Communication
							\item Simplicity
								\begin{itemize}
									\item "Live for today"
								\end{itemize}
							\item Feedback
								\begin{itemize}
									\item "Learning to drive"
								\end{itemize}
							\item Courage
						\end{enumerate}
					\item Twelve Core Practices
						\begin{enumerate}
							\item The Planning Game
							\item Small releases
							\item Metaphor
							\item Simple design
							\item Testing
							\item Refactoring
							\item Pair programming
							\item Collective ownership
							\item Continuous integration
							\item 40-hour week
								\begin{itemize}
									\item Not allowed to work overtime two weeks in a row.
								\end{itemize}
							\item On-site customer
							\item Coding standards
						\end{enumerate}
					\item Cool features
						\begin{itemize}
							\item Food
							\item Parties after releases
							\item Interesting office arrangement
							\item No documentation
						\end{itemize}
				\end{itemize}
			\subsection{Michael Debs}
				\begin{itemize}
					\item Working software over comprehensive documentation
					\item Responding to change over following a plan
					\item Simplicity
					\item Refactoring
					\item Pair programming
					\item Collective ownership
						\begin{itemize}
							\item Trust
						\end{itemize}
					\item Small Development teams
				\end{itemize}
		\section{DSDM}
			\textit{Patrick Lindsay}
		\section{Scrum}
\end{document}