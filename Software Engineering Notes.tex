\documentclass{report}

\author{Patrick Lindsay}
\title{Software Engineering Notes}

\newcommand*{\glossaryname}{Dictionary}
\usepackage[nonumberlist]{glossaries}
\newcommand{\define}[2]{%
 \newglossaryentry{#1}{name=#1, description={#2}}%
 \glslink{#1}{}%
}
\makeglossaries

\begin{document}
\maketitle
\tableofcontents
\newpage
\part{Notes}
\chapter{January 15, 2012}
	\section{Overview}
	\underline{Software Engineering} - The application of sound engineering practices to software creation and maintenance.
		\subsection{Software development Life Cycle (Traditional Approach)}
			\begin{itemize}
				\item Requirements Phase
				\item Analysis or Specification Phase
				\item Design Phase
				\item Implementation/Integration Phase
				\item Maintenance Phase
				\item Retirement
			\end{itemize}
		\subsubsection{Requirements Phase}
			\begin{itemize}
				\item Determining the \textsc{needs} and \textsc{wants} of the client or customer.
				\item Determining the constraints of the system.
			\end{itemize}
		\subsubsection{Analysis or Specification Phase}
			\begin{itemize}
				\item After analyzing the requirements, construct a \emph{specification document} which explicitly describes what the product is to do, and the constraints under which it must operate.
				\item This includes the description of the input, output, actions, and UI.
				\item The specification document can be used as part of a contract with the client.
			\end{itemize}
			\paragraph{Problems with the Spec Document}
			\begin{enumerate}
				\item Ambiguity - one sentence may have more than one interpretation.
				\item Incompleteness - relevant fact or requirement is left out.
				\item Contradiction - two places in the spec document are in conflict.
			\end{enumerate}
		\subsubsection{Design Phase}
			\begin{itemize}
				\item Construct an \emph{Architectural Design}.
				\item Construct a \emph{Detailed Design}.
				\item Test for \emph{traceability}.
			\end{itemize}
			\begin{enumerate}
				\item \underline{Architectural Design} - Description of the product in terms of modules.
				\item \underline{Detailed Design} - Description of each module.
				\item \underline{Traceability} - each part of the design can be traced to a statement in the specification document.
			\end{enumerate}
		\subsubsection{Implementation Phase}
			\begin{itemize}
				\item Code each module from the detailed design.
				\item Programmer tests his/her own code separately.
				\item Modules are combined and tested by developers.
				\item Product is tested by SQA group. This is called product testing.
				\item Project is given to the client for acceptance testing.
			\end{itemize}
		\subsubsection{Maintenance Phase}
			\begin{itemize}
				\item Corrective Maintenance - bug squashing
				\item Enhancement Maintenance - Updates
				\begin{itemize}
					\item Perfective - client makes new demands
					\item Adaptive - changes in the environment of the product requires changes in the software.
				\end{itemize}
				\item Perform regression testing - insuring that changes have not affected already working functionality.
			\end{itemize}
		\subsubsection{Retirement Phase}
			\begin{itemize}
				\item Determining if desired changes are too costly.
				\item Determining if a product is obsolete.
			\end{itemize}
	\subsection{Four Components of the Software Engineering Enterprise}
	The four P's
	\begin{enumerate}
		\item Process
		\item Project
		\item People
		\item Product
	\end{enumerate}
		\subsubsection{Process}
			\begin{itemize}
				\item The process is sometimes called the life-cycle model or development sequence.
				\begin{itemize}
					\item Waterfall
					\item Spiral
					\item Incremental Build
				\end{itemize}
				\item Makes use of several process frameworks.
				\begin{itemize}
					\item Personal Software Process (PSP)
					\item Team Software Process (TSP)
					\item Capability Maturity Model (CMM)
				\end{itemize}
				\item Documentation Standards
				\begin{itemize}
					\item IEEE
					\item ANSI
				\end{itemize}
			\end{itemize}
		\subsubsection{Project}
			\begin{itemize}
				\item The set of activities needed to produce the required product.
				\item Project management is extremely important.
				\item Many projects are not about developing new products, but maintaining already existing \emph{legacy} systems.
			\end{itemize}
		\subsubsection{People}
			\begin{itemize}
				\item Team Organization
				\item Team Management
				\item Relationship with customer or client
				\item Relationship with end users
				\item Communication with upper management
			\end{itemize}
		\subsubsection{Product}
			Includes
			\begin{itemize}
				\item Requirement Specification Document
				\item Design Document
				\item Source Code
				\item Executable
				\item User Manuals
			\end{itemize}
\chapter{January 17, 2013}
	\section{Traditional Software Engineering Process}
		\subsection{Historical Influences}
			\begin{itemize}
				\item Structured programming (Edsger Dijkstra's letter calling "GOTOs" harmful) uses sequence control, iteration, invoking functions
				\item Object Oriented paradigm: the use of objects with data and functionality which can represent real-world entities.
			\end{itemize}
			\textit{Note:\\Silver Bullet ca. 1980s\\ Likened the software crisis to a werewolf.  Object Oriented Paradigm was the Silver Bullet.\\It did not work as expected.}
			\begin{itemize}
				\item Design Patterns: stock of reusable design elements (templates)
			\end{itemize}
		\subsection{Component Reuse}
			A component as defined by Meyer is "a program element satisfying:"
			\begin{enumerate}
				\item The element may be used by other program elements. (Clients)
				\item The clients and their authors do not need to be known to the element's author
			\end{enumerate}
		\subsection{Key Expectations of Software Engineering}
			\begin{enumerate}
				\item Decide in advance what the specific quality measures are to be for the project and product.\\
					\textit{Predetermine quantitative quality goals.}
				\item Gather data on all projects to form a basis for estimating future projects.
				\item All requirements, designs, code and test materials should be freely and easily available to all members of the team.\\
					\textit{Source code should always be available to all team members in an easily accessible and interpreted way.\\
								Git, Mercurial, etc.}
				\item A process should be followed by all team members. \textit{Uniformity}
					\begin{enumerate}
						\item Design only against requirements.
						\item Program only against design.
						\item Test only against requirements and design.\\
						\textsc{Always follow the recipe!}
					\end{enumerate}
				\item Measure and achieve quality goals.
			\end{enumerate}
	\section{Methods}
		\emph{Be able to draw and discuss these.}
		\subsection{Waterfall Method}
			\textsc{See diagram 52.9 on pg 53.}
			\begin{itemize}
				\item First described by William\textit{(?)} Royce in 1970.
				\item No phase is complete until documentation for that phase has been completed and approved by the SQA group.\\
					\textit{Very orderly; heavy on documentation.}
				\item Has been used with great success on a variety of products.
				\item Feedback loops permits modifications to be made to the previous phase.
			\end{itemize}
			\subsubsection{Advantages}
				\begin{enumerate}
					\item Enforced disciplined approach
					\item Requirement that documentation be provided at each phase.
					\item All products of the phase must be checked by SQA.
					\item Inherent aspect of each phase is testing.
				\end{enumerate}
			\subsubsection{Disadvantages}
				\begin{itemize}
					\item The resulting specification document may not be able to be understood by the client.
					\item It can lead to the construction of product that does not meet the client's needs.					
				\end{itemize}
		\subsection{Rapid Prototype Model}
			\textsc{See diagram on pg 55.}
			Construction of a functional subset of the desired product in order to allow the client and the developer to interact.\\
			\textit{Keyword is rapid.  This is a thrown-together, proof-of-concept type project; a mock-up.}
			\subsubsection{Advantages}
				\begin{itemize}
					\item The process is linear and possibly faster than the Waterfall Model
					\item Increases interaction between client and developer.
				\end{itemize}
			\subsubsection{Disadvantages}
				\begin{itemize}
					\item Client may inaccurately think the product is almost complete when viewing the prototype.
					\item Developer may attempt to use the prototype as part of the final product.
				\end{itemize}
		\subsection{Waterfall-Rapid Prototype Hybrid}
			May form a hybrid model using the rapid prototype as the first phase in the Waterfall Model in order to increase interaction but allow for feedback loops within the development of the product.
		\subsection{Incremental Model}
			Software is implemented, integrated, and tested as a series of incremental builds.\\
				\textit{Code pieces providing specific functions.}
			\subsubsection{Advantages}
				\begin{enumerate}
					\item Results in builds which can be developed in weeks, not months or years.
					\item End user need not learn the entire product at one time.
					\item Client need not pay for the entire product at one time.
					\item Developer gets paid earlier.\\ (At each build delivery)
					\item Open-ended design makes maintenance easier.
					\item Easier to make changes during development.
				\end{enumerate}
			\subsubsection{Disadvantages}
				\begin{enumerate}
					\item Each new build must fit in without destroying existing builds.\\
						\textit{Regression Testing}
					\item Requires more careful to design to make it open to additions.
					\item Can degenerate to a build and fix product if broken into too few builds.
				\end{enumerate}
		\subsection{Spiral Model}
			\textsc{See Figure 2.12 on pg 63 and Figure 2.13 on pg 65.}
			\begin{itemize}
				\item A Waterfall Model with each phase preceded by risk analysis in an attempt to control or resolve risk.
				\item Each phase is 360º.
				\item The measure of the radius is the cumulative cost to date.
				\item The measure of the angle is the progress measure.\\
					\textit{Each phase is 360º.\\
								Requires a very experienced engineer.}
			\end{itemize}
			\subsubsection{Advantages}
				\begin{enumerate}
					\item The emphasis on alternatives and constraints supports the reuse of existing software.
					\item The incorporation of software quality as a specific objective.
					\item Answers the question of how much testing should be performed in terms of risks.
					\item Maintenance is simply another cycle of the spiral, the same as development.
				\end{enumerate}
			\subsubsection{Disadvantages}
				\begin{enumerate}
					\item Intended exclusively for internal development.\\
						\textit{Client and developer are members of the same organization.}
					\item \emph{Applicable only to large-scale projects.}
					\item Must have developers who are skilled at pinpointing the possible risks.
				\end{enumerate}
		\section{Agile Methods}
			\subsection{General}
				According to the Agile Manifesto, they value:
				\begin{itemize}
					\item Individuals and interactions over processes and tools.
					\item Working software over comprehensive documentation.
					\item Customer collaboration over contract negotiation.
					\item Responsiveness to change over following a plan.\\
						\textsc{You don't always have to follow the recipe!}
				\end{itemize}
				\subsubsection{Traits}
					\begin{itemize}
						\item Highly iterative
						\item Pair programming with a focus on teamwork and ego-less programming.\\
							\textsc{This is mandatory.}
						\item Early and planned testing.
						\item Story cards \textit{Similar to storyboards in movies.}
						\item Refactoring \textit{Turning working code into better code.}
						\item Feedback
					\end{itemize}
				\subsubsection{Principles Behind the Agile Manifesto}
					\begin{enumerate}
						\item Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
						\item Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive disadvantage.
						\item Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.
						\item Business people and developers must work together daily throughout the project.
						\item Build projects around motivated individuals. Give them the environment and support they need and trust them to get the job done.
						\item The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
						\item Working software is the primary measure of progress.
						\item Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
						\item Continuous attention to technical excellence and good design enhances agility.
						\item Simplicity - the art of maximizing the amount of  work not done - is essential.
						\item The best architectures, requirements, and designs emerge from self-organizing teams.
						\item At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.
					\end{enumerate}
	\chapter{January 22, 2013}
		\section{Refactoring}
			\begin{itemize}
				\item Reduce software complexity
				\item Improve internal structure while preserving the behavior of the code.\\
					\textit{Prettifying}
				\item Improve software quality\\
					\textit{Readability, execution efficiency, size efficiency, etc.}
				\item Performed in response to "bad smells" in the code, undesirable characteristics\\
					\textit{Martin Fowler}
				\item Automated or manual\\
			\end{itemize}
		\section{Teams}
			\underline{Team} - a group of professionals organized in order to complete the task of creating a large software project.
			\subsection{Team Structure}
				\subsubsection{Project Factors Related to Structure of the Team}
					\begin{enumerate}
						\item Difficulty of the problem
						\item Size of the program in LOC or Function Points\\
							\textit{LOC stands for Lines of Code}
						\item Time the team will stay together
						\item Degree of modularity for program
						\item Required quality and reliability
						\item Rigidity of delivery date
						\item Degree of communication required
					\end{enumerate}
				\subsubsection{Jelled Team}
					\begin{itemize}
						\item A group of people which are so tightly knit that the attitude is that the whole is greater than the sum of the parts
						\item Egos are forgotten and the team becomes important
						\item Exhibits cohesiveness, team spirit, common definition of success
						\item Generally more productive, more motivated, and happier
					\end{itemize}
				\subsubsection{Why Don't All Teams Jell?}
					\begin{itemize}
						\item A frenzied work atmosphere
						\item High frustration causing friction among team members
						\item A "fragmented or poorly coordinated" software process
						\item An unclear definition on the team
						\item "Continuous and repeated exposure to failure" - M. Jackman \textit{Homeopathic Remedies for Team Toxicity}
					\end{itemize}
				\subsubsection{Necessary Team Traits}
					Personality
					\begin{itemize}
						\item Openness - intellectual curiosity
						\item Conscientiousness - self-discipline, pushing toward goals
						\item Extroversion - energy, emotions, seek company of others\\
							\textit{Being a people person}
						\item Agreeableness - compassionate and cooperative
						\item Neuroticism - how a person responds to stress, emotional stability
					\end{itemize}
				\subsubsection{How to Make Personality Traits Work}
					\begin{enumerate}
						\item Recognize people have different types of personalities
						\item Assemble a diverse team covering a range of personalities
						\item Create an open, honest, tolerant atmosphere in team meetings
					\end{enumerate}
			\subsection{Roles}
				\begin{itemize}
					\item \underline{Team Leader} - Responsible for overseeing all aspects of the team project; holds the tie-breaking vote.
					\item \underline{Technical Lead} - Expert on all technical aspects of the project, in particular the hardware and software used for development.
					\item \underline{Designer} - Designs the project and breaks the project into smaller pieces (\textit{Modules}) for the programmers.
					\item \underline{Lead Programmer} - Needs to have an understanding of the project as a whole; organizes all of the other programmers.
					\item \underline{Technical Writer} - Writes all documentation for the project (\textit{Team meeting minutes, Specification Document, Users' Manual})
					\item \underline{Configuration Management} - Maintains the code base for the project; could include CVS responsibilities.
					\item \underline{Quality Assurance} - Writes, maintains, and conducts all testing associated with the project.
				\end{itemize}
			\subsection{Organizational Structures}
				\begin{itemize}
					\item Democratic Team
					\item Hierarchical or Chief Programmer
					\item Team Manager/Team Leader
					\item Synchronize-and-Stabilize Team
					\item Agile Team
				\end{itemize}
				\subsubsection{Democratic Team}
					\begin{itemize}
						\item Group of up to 10 programmers
						\item Equal partnership with egoless programming
						\item Works well if the group is small, highly competent
						\item Problem with who is in charge
						\item Positive attitude about finding fault
						\item Good in research environment with difficult problem
					\end{itemize}
				\subsubsection{Hierarchical or Chief Programmer}
					\begin{itemize}
						\item One overall manager (\textit{Chief Programmer})
						\item Everyone understands the lines of authority\\
							\textit{One boss.}
						\item Team members tend to participate less in decisions; decisions are handed down from above
						\item May have a Programming Secretary and a Backup Programmer for the Chief Programmer
						\item Difficult to find one person adept at both managing and programming.
					\end{itemize}
				\subsubsection{Team Manager/Team Leader}
					\textit{See Figure 4.4, pg. 114}
					\begin{itemize}
						\item Split the responsibilities of Chief Programmer into Team Manager and Team Leader
						\item The Team Manager handles the nontechnical management
						\item The Team Leader deals with the technical issues of the project
						\item Results in programmers having two bosses
						\item May be difficult to determine if an issue is technical or nontechnical
					\end{itemize}
					\paragraph{Technical Organizational Structure for Large Projects}
						\begin{itemize}
							\item One Project Leader oversees several team leaders
							\item Each team leader has several programmers for which he/she is responsible
							\item Clear lines of communication\\
								\textit{Two level structure}
						\end{itemize}
				\subsubsection{Synchronize-and-Stabilize Team}
					\textit{Has been used by Microsoft}
					\begin{itemize}
						\item Small team led by a manager and having three to eight developers and three to eight testers working one-to-one with the developers
						\item Developers are given freedom to design and implement their portions as they wish
						\item Each day, the partial components are tested and debugged.
						\item Encourages creativity and innovation yet the daily synchronization keeps the project on track.
					\end{itemize}
				\subsubsection{Agile Team}
					\begin{itemize}
						\item Work in pairs (\textsc{Mandatory})
						\item Provide instant review
						\item Create test cases which are used for daily testing
						\item Remove the problem if one developer leaves, the knowledge does not disappear about a portion of the project
					\end{itemize}
	\chapter{January 24, 2013}
		\section{Tools for Software Engineers} 
			\begin{itemize}
				\item  Analytic (Theoretical) Tools:
					\begin{enumerate}
						\item  Stepwise Refinement
						\item Cost-Benefit Analysis
						\item Divide-and-Conquer
						\item Separation of Concerns
						\item Software Metrics
					\end{enumerate}
				\item Software Tools (CASE: Computer-Aided Software Engineering)
			\end{itemize}
			\subsection{Analytic Tools}
				\subsubsection{Stepwise Refinement}
					\begin{itemize}
						\item Process whereby a project is successively decomposed into more detailed instructions.
						\item In each step, a given task is written as a set of subtasks.
						\item Term was first coined by Niklaus Wirth in 1971.
						\item Helps to concentrate on relevant aspects of the current development phase and ignore details that need not be considered.
						\item A postponement of decisions on details until as late as possible.
						\item Critical to object-oriented paradigm.
					\end{itemize}
				\subsubsection{Cost-Benefit Analysis}
					\begin{itemize}
						\item Comparing estimated future benefits against future costs for a certain decision.
						\item Problems occur in that intangible benefits may be hard to quantify.
						\item May use past experience to project the estimates for benefits or costs.
					\end{itemize}
				\subsubsection{Divide-and-Conquer}
					\begin{itemize}
						\item Most agree this is the oldest analytical tool used in Software Engineering.
						\item Break a large problem into smaller subprograms that should be easier to solve.
						\item Idea used in the Unified Process.
						\item Good concept but no details in the how... \textsc{GET THIS BULLET}
						\item \textit{Key difference from Stepwise Refinement is that Divide-and-Conquer does not necessarily procrastinate details.}
					\end{itemize}
				\subsubsection{Separation of Concerns}
					\begin{itemize}
						\item First introduced by Dijkstra in 1974.
						\item Process of breaking a software project into components which overlap as little as possible in relationship to functionality.
						\item Regression faults are minimized.\\
							\textit{If every component does one function (High Cohesion), making changes won't affect a lot of things.}
						\item Components are more reusable.
					\end{itemize}
				\subsubsection{Software Metrics}
					Measurements used to indicate:
					\begin{itemize}
						\item Size (LOC - Lines of Code)
						\item Duration (Months, years)
						\item Effort (Person-Months)
						\item Quality (Fault Density - Faults/1000LOC)
						\item Efficiency (Faults/Unit of time)
						\item Reliability (Mean time between failures)
					\end{itemize}
					Product/Process
			\subsection{CASE Tools}
				\begin{itemize}
					\item UpperCASE or front-end tools - used in the requirements, analysis and design workflows
					\item LowerCASE or back-end tools - used in the implementation and maintenance activities
				\end{itemize}
				\subsubsection{Types of CASE Tools}
					\begin{itemize}
						\item Data Dictionary - computerized list of all data defined within the product (type and location defined)\\
							\textit{Could be Upper or LowerCASE}
						\item Consistency Checker - tool which checks that everything in the design is in the specification document and everything in the specification document is in the design.
						\item Report Generator - tool which generates code needed for producing a report.
						\item Screen Generator - tool which generates the code necessary for a data capture screen.
						\item Structured Editor - a text editor which is designed to understand the structure of a program in a programming language, aiding in syntax fault prevention or early detection.
						\item Pretty Printer or Formatter - code often included with the structured editor which makes use of the language syntax structure to display the code in a standard manner (indenting, highlighting reserved words or comments)\\
							\textit{Try Sublime Text 2!}
						\item On-line Interface Checker - editor know every subprogram declared within the product and their parameter lists.
						\item Operating System Front End - tool which allows the programmer to give commands to the operating system from within the editor.
						\item Source Level Debugger \textit{LowerCASE}
						\item Interactive Source Level Debugger \textit{LowerCASE}
						\item Version Control Tool - keeps detailed record of each version of the project.\\
							\textit{Check out Git with GitHub or BitBucket!}
						\item Configuration Control Tool - manages multiple variations. \textit{LowerCASE}
					\end{itemize}
				\subsubsection{Grouped CASE Tools}
					\begin{itemize}
						\item CASE Workbench - collection of CASE tools that together support one or two activities.
						\item CASE Environment - collection of CASE tools which support the entire software process.
					\end{itemize}
		\section{Software Versions}
			\begin{itemize}
				\item During maintenance, at least two versions of the product will exist: the old version and the new version.
				\item \underline{Revision} - what we call the new version.
				\item \underline{Configuration} - the specific version of each artifact from which a given version of the complete product is built.
			\end{itemize}
	\chapter{January 29, 2013}	
		\section{Phases of Unified Process}
			\subsection{Inception Phase}
				\begin{itemize}
					\item Determine whether it's worthwhile to develop the target product
					\item Determine economic viability
					\item Steps
						\begin{enumerate}
							\item Obtain domain knowledge
							\item Build business model\\
								\textit{Understand how the client operates within the domain.}
						\end{enumerate}
				\end{itemize}
				Questions to consider:
				\begin{enumerate}
					\item Is the proposed software cost effective?
					\item Can the proposed software be delivered on time?
					\item What risks are involved in developing the software and how can these risks be mitigated?
				\end{enumerate}
				Identify Risks
				\begin{enumerate}
					\item Technical risks
					\begin{itemize}
						\item Necessary experience?
						\item New hardware needed and will it be delivered on time?
						\item Software tools needed?
					\end{itemize}
					\item Not getting the requirements right
					\item Not getting the architecture (design) right
				\end{enumerate}
				\subsubsection{Documentation in the Inception Phase}
					\begin{itemize}
						\item Initial version of the domain model
						\item Initial version of the business model
							\textit{How the client operates in their domain.}
						\item Initial version of the requirements artifacts
						\item Preliminary version of the analysis artifacts
						\item Preliminary version of the architecture
						\item Initial list of risks
						\item Initial use cases
						\item Plan for elaboration phase
						\item Initial version of the business case\\
							\textit{Document that describes the cost-effectiveness of taking on the project}
					\end{itemize}
			\subsection{Elaboration Phase}
				\begin{itemize}
					\item The aim is to refine the requirements, refine the architecture, monitor the risks, refine the business case, and produce the software project management plan.
					\item Major activities are refinements of the previous phase.
				\end{itemize}
				\subsubsection{Elaboration Phase Deliverables}
					\begin{itemize}
						\item Completed domain model
						\item Completed business model
						\item Completed requirements artifact
						\item Completed analysis artifacts
						\item Updated version of the architecture
						\item Updated list of risks
						\item Software Project Management Plan (SPMP)
						\item Completed business case
					\end{itemize}
			\subsection{Construction Phase} 
				\begin{itemize}
					\item Aim is to produce the first operational-quality version of the product (beta release)
					\item Emphasis is on implementation and testing
					\item Components are coded and unit tested
					\item Components are combined (integrated) and tested again.
				\end{itemize}
				\subsubsection{Construction Phase Deliverables}
					\begin{itemize}
						\item Initial user manual and other manuals as needed
						\item All the artifacts of the beta release version
						\item Completed architecture
						\item Updated risk list
						\item Software Project Management Plan (SPMP)
						\item Updated business case if needed
					\end{itemize}
			\subsection{Transition Phase}
				\begin{itemize}
					\item Aim is to ensure that the client's requirements have been met
					\item Driven by feedback from the locations where the beta version is installed and tested
					\item Manuals are completed
					\item Faults are corrected
					\item Discover any unidentified risks
				\end{itemize}
				\subsubsection{Transition Phase Deliverables}
					\begin{itemize}
						\item All the artifacts of the final version
						\item Completed manuals
					\end{itemize}
					Refer to pg. 88 of the book.
		\section{Testing}
			\underline{Testing} - continual process carried on during the entire life cycle of software.\\
			\paragraph{V and V}
				\begin{itemize}
					\item Verification - determining whether a phase has been correctly carried out (at the end of the phase) 
					\item Validation - testing just before a product is delivered to the client to determine if it satisfies the specifications
				\end{itemize}
			\paragraph{Use of the Term Testing}
				We use the term testing instead of V and V because they imply that testing can wait until certain points in the process like the end of a phase, when testing must occur throughout the process.
			\subsection{Fault, Failure, Error, Defect}
				\begin{itemize}
					\item Fault - human mistake created in software
					\item Failure - observed incorrect behavior due to a fault
					\item Error - amount by which a result is incorrect 
					\item Defect - generic term used to encompass fault, failure, and error
				\end{itemize}
		\section{Software Quality}
			\begin{itemize}
				\item Extent to which the product satisfies its specifications
				\item Adherence to specifications
				\item Must be ensured at all times, not just added at the end of the product
				\item Every software developer must be personally responsible for the quality of their work.
			\end{itemize}
			\subsection{Software Quality Assurance}
				SQA group oversees the quality throughout the process
				\begin{itemize}
					\item Adherence to standards
					\item Correctness of each workflow
					\item Independent of the development team
				\end{itemize}
			\subsection{Categories of Testing}
				\begin{enumerate}
					\item Non-Execution-Based Testing (Reviews)
						\begin{itemize}
							\item Walkthroughs
								\begin{itemize}
									\item 4-6 person team  (Experience Senior Staff)
									\begin{itemize}
										\item Manager of the current workflow
										\item Member of the team on the current workflow
										\item Member of the team on the subsequent workflow
										\item Client Representative
										\item SQA group member
									\end{itemize}
									\item Material distributed to allow participants to prepare
									\item Each reviewer develops two lists: things they don't understand, things they think are incorrect
									\item Purpose is to find faults in a workflow or document such as the specification or the design document and create a list of faults for later correction
									\\\\
									Ways to conduct a walkthrough
									\begin{enumerate}
										\item Participant Driven - members present their lists to the team creating the document being tested which respond to each item (clarify questions, repair faults)
										\item Document Driven - chair walks the members through the document with stops at the unclear or possible faults
									\end{enumerate}
								\end{itemize}
							\item Inspections
								\begin{itemize}
									\item Proposed by Fagan in 1976 for testing designs and 
									\item Consists of five formal steps
									\item Conducted by team of size 4-5
										\begin{itemize}
											\item Moderator - both manager and leader of the inspection team
											\item Reader - leads team through the document
											\item Recorder - produces written report of detected faults
											\item Implementer/Tester
										\end{itemize}
									\item Steps:
										\begin{enumerate}
											\item Overview - presentation by one individual responsible for producing it after which given to participants
											\item Preparation - participants try to understand the document using lists of fault types and create checklist
											\item Inspection - one participant walks through using the checklists with the moderator creating a written report
											\item Rework - using the written report of faults, the individuals which created the document resolve the faults
											\item Follow-Up - moderator makes sure that everything in the report has been corrected or addressed and that no new faults were created in repairing the original faults
										\end{enumerate}
								\end{itemize}
						\end{itemize}
					\paragraph{Comparison of Walkthroughs and Inspections}
						\begin{itemize}
							\item Walkthroughs are 2 steps and inspections are more formal 5 steps 
							\item Inspections generally take longer but the extra time and effort spent can be cost effective
						\end{itemize}
					\item Execution-Based Testing
				\end{enumerate}
\end{document}